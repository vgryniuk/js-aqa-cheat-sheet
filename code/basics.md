# Базові концепції JS 
---

**Змінні (Variables):** Змінні за допомогою ключового слова `let`, const або `var` і можуть змінюватись (let) або залишатись постійними (const).

```
var x = 1;
let y = 2;
const z = 3;
```

Загалом, рекомендують використовувати `let` замість `var`, оскільки `let` забезпечує більш прогнозований та безпечний підхід до роботи зі змінними, обмежуючи їхню область видимості і уникнення підняття (hoisting), що може призводити до неочікуваної поведінки в коді.

---

**Функції (Functions):** - це блоки коду, які можна викликати для виконання певних дій. Вони оголошуються за допомогою ключового слова function. Усі функції в JS є об'єктами.

```
function add(x, y) {
    return x + y;
}
```
---

Цикли (Loops): Цикли дозволяють виконувати певний блок коду декілька разів. JS має кілька видів циклів: 
* For Loop
* For-In Loop
* For-Of Loop
* While Loop
* Do-While Loop

```
for(i=1; i<=5; i++){
    console.log(i);   
 }
```

**For-in** - використовується для перебору всіх властивостей об'єктів.
```
const obj = { a: 1, b: 2, c: 3 };

for (let prop in obj) {
  console.log(prop); // виведе 'a', 'b', 'c'
  console.log(obj[prop]); // виведе значення: 1, 2, 3
}
```

**For-of** - використовується для перебору значеннь у колекціях.
```
const arr = [1, 2, 3];

for (let elem of arr) {
  console.log(elem); // виведе значення: 1, 2, 3
}
```

**While** - перевіряє умову перед виконанням кожної ітерації циклу.
```
let i = 0;

while (i < 5) {
  console.log(i);
  i++;
}
```

**Do-while** - гарантує виконання тіла циклу принаймні один раз.
```
let i = 0;

do {
  console.log(i);
  i++;
} while (i < 5);
```
---

**Оператори рівності та ідентичності**: Оператори `==` і `===` в JavaScript використовуються для порівняння значень, але вони мають різні принципи роботи:

* **== (оператор рівності):**
        `==` перевіряє рівність двох значень, при цьому виконується приведення типів для порівняння. Наприклад, `5 == '5'` поверне `true`, оскільки значення після приведення типів будуть однаковими.
* **=== (строгий оператор рівності, також відомий як оператор ідентичності):**
        `===` також порівнює значення, але без приведення типів. Порівняння відбувається за значенням і типом. Це означає, що обидва операнди повинні бути одного і того ж типу, а потім порівнюються значення. Наприклад, `5 === '5'` поверне `false`, оскільки типи операндів відрізняються.

---
### var let const
**`var`**
* Якщо змінні оголошені через `var` в середині функції, вони мають функціональну область видимості (function scope), що означає, що вони доступні лише всередині функції, у якій були оголошені (включаючи блоки коду).
* Якщо змінна була оголошена через `var` за межами будь-якої функції, вона буде глобальною змінною. Оголошення var поза будь-якою функцією робить цю змінну доступною в усьому файлі (якщо це модуль Node.js) або на рівні глобальної області видимості (якщо це браузерний JavaScript). Це може призвести до проблем з масштабованістю програми через можливість конфліктів імен змінних.
* Змінні `var` можуть бути переоголошені та переназначені, іншими словами, їхні значення можна змінювати після оголошення.

**`let`**
* `let` використовує блочну область видимості (block scope), тобто змінні, оголошені з використанням `let`, видимі лише всередині блока, у якому вони оголошені (блок - це частина коду, закрита у фігурні дужки {}).
* Змінні `let` також можуть бути переназначені, але не можуть бути знову оголошені у тому ж самому блоку.

**`const`**
* `const` також має блочну область видимості і працює так само, як `let` в цьому аспекті. Відмінність полягає у тому, що змінні, оголошені за допомогою `const`, повинні бути ініціалізовані при оголошенні, і після цього їхнє значення не можна змінити. Це означає, що `const` створює константу, значення якої залишається незмінним протягом життєвого циклу змінної.
---

### String
В JavaScript рядки (strings) використовуються для зберігання та обробки текстової інформації. Рядок - це послідовність символів, що може включати літери, цифри, символи пунктуації та спеціальні символи. У JavaScript рядки є об'єктами і мають власні властивості та методи. Рядки можна ініціалізувати за допомогою подвійних лапок `"` або одинарних лапок `'`. 
```
let str1 = "Це рядок з подвійними лапками";
let str2 = 'Це рядок з одинарними лапками';
```
Основні властивості рядків:
* **length:** Повертає довжину рядка (кількість символів).
* **concat():** Об'єднує два або більше рядків та повертає новий рядок.
* **toUpperCase() і toLowerCase():** Перетворюють рядок у верхній чи нижній реєстр відповідно.
* **indexOf() і lastIndexOf():** Повертають позицію першого чи останнього входження підрядка у рядок.
* **slice():** Вирізає частину рядка та повертає новий рядок.
* **split():** Розбиває рядок на масив підрядків за вказаним розділювачем.
---

### Створення та ініціалізація об'єктів:

* **Літеральний спосіб:** Об'єкти можна створювати безпосередньо за допомогою фігурних дужок та визначення властивостей та їх значень:

```
let person = {
  firstName: "John",
  lastName: "Doe",
  age: 30,
  hobbies: ["reading", "hiking", "cooking"],
  address: {
    street: "123 Main St",
    city: "Anytown",
    country: "Country"
  }
};
```

* **Використання конструктора Object():** Об'єкт можна створити за допомогою конструктора Object() та додавати властивості:

```
    let car = new Object();
    car.make = "Toyota";
    car.model = "Corolla";
    car.year = 2022;
```

* **Основні властивості об'єктів:** Властивості у об'єктів представляють собою пари "ключ-значення" і можуть бути доступні та змінені:
```
let person = {
  firstName: "John",
  lastName: "Doe",
  age: 30
};

console.log(person.firstName); // Виведе: John
person.age = 31;
console.log(person.age); // Виведе: 31
```

* **Вкладені об'єкти:** Об'єкти можуть містити в собі інші об'єкти як властивості.
* **Масиви в об'єктах:** Об'єкти можуть також містити масиви як властивості:
* **`hasOwnProperty()`:** Метод `hasOwnProperty()` перевіряє, чи має об'єкт певну власну властивість (тобто властивість, яка не успадкована від прототипу).
```
let person = {
  name: "John",
  age: 30
};

console.log(person.hasOwnProperty("name")); // Результат: true
console.log(person.hasOwnProperty("toString")); // Результат: false (цей метод успадкований)
```
* **`keys()`:** Метод `Object.keys()` повертає масив зі всіма перелічуваними властивостями об'єкта у вигляді рядків. Мметод корисний, коли потрібно отримати список ключів у об'єкта для подальшої обробки чи ітерації.
```
let person = {
  name: "John",
  age: 30
};

let keys = Object.keys(person);
console.log(keys); // Результат: ["name", "age"]
```
* **`getOwnPropertyDescriptor()`:** Метод `Object.getOwnPropertyDescriptor()` повертає дескриптор властивості для вказаного ключа об'єкта. Дескриптор включає характеристики властивості, такі як value, writable, enumerable, та configurable.
```
let person = {
  name: "John",
  age: 30
};

let descriptor = Object.getOwnPropertyDescriptor(person, "name");
console.log(descriptor);
// Результат: { value: 'John', writable: true, enumerable: true, configurable: true }
```
* **`defineProperty()`:** Метод `Object.defineProperty()` дозволяє додати або змінити властивість об'єкта з вказаними характеристиками.
```
let person = {};

Object.defineProperty(person, "name", {
  value: "John",
  writable: true,
  enumerable: true,
  configurable: true
});

console.log(person.name); // Результат: "John"
```
---
**Замикання (closure)** в JavaScript - це концепція, коли функція має доступ до змінних з області видимості, в якій вона була створена, навіть після того, як ця область видимості закінчилася. Closure може бути корисним там, де потрібно зберігати стан, забезпечуючи приватність даних або виконуючи певні дії з доступом до локальних змінних функції. 


Типові сценарії, де використання замикань може бути корисним:

* **Фабричні функції:** Вони створюють і повертають об'єкти, що мають доступ до приватних змінних. 
```
function createCounter() {
  let count = 0;
  return function() {
    return ++count;
  };
}
let counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```
* **Обробники подій:** При роботі з подіями можна використовувати замикання для збереження даних та створення інкапсульованих обробників.
```
function onClickHandler() {
  let count = 0;
  return function() {
    count++;
    console.log(`Button clicked ${count} times`);
  };
}
let clickHandler = onClickHandler();
document.getElementById('myButton').addEventListener('click', clickHandler);
```
* **Модулі:** Замикання використовуються для імітації приватних методів і змінних у модулях, що допомагає уникнути змішування змінних в глобальному просторі імен.
```
    let myModule = (function() {
      let privateVariable = 'I am private';

      function privateMethod() {
        console.log('This is a private method');
      }

      return {
        publicMethod: function() {
          console.log('This is a public method');
        },
      };
    })();

    myModule.publicMethod(); // Звернення до публічного методу
```
---
### this
**`this`** в JavaScript - це спеціальне ключове слово, яке вказує на поточний об'єкт у контексті, в якому воно використовується. Значення `thi`s залежить від того, де використовується і як саме було викликано.
##### Значення this в залежності від контексту:
* **Глобальний контекст**: У глобальному контексті `this` вказує на об'єкт `window` в браузері або `global` в середовищі Node.js.
* **Метод об'єкта**: У випадку методу об'єкта `this` вказує на сам об'єкт, до якого він відноситься.
```
const myObject = {
  myMethod() {
    console.log(this); // this вказує на об'єкт myObject
  },
};
myObject.myMethod();
```
* **Контекст функції**: У звичайній функції `this` може мати різні значення в залежності від того, як вона була викликана. Якщо функція викликана як метод об'єкта, то `this` вказує на той об'єкт, якому належить метод. Якщо вона викликана безпосередньо, то значення `this` може змінюватись.
```
function myFunction() {
  console.log(this); // this може мати різні значення
}

const obj1 = { method: myFunction };
const obj2 = {};

obj1.method(); // this вказує на obj1
myFunction(); // this вказує на window (браузер) або global (Node.js)
```
* **Конструктор**: У конструкторі, `this` вказує на новостворений об'єкт.
```
    function MyClass() {
      this.value = 10;
    }

    const obj = new MyClass();
    console.log(obj.value); // Виведе: 10
```
---